<template>
  <div class="tab-content">
    <form action="#" v-on:submit.prevent="submitNewItem">
      <Row>
        <Col span="18">
            <Input ref="mainInput"
                   :autofocus="true"
                   v-model="newTodoItem"
                   placeholder="Type and hit Enter"
                   size="large"
                   @on-enter="submitNewItem"
                   @on-click="submitNewItem"
                   icon="plus"
                   class="animated"
                   :class="{'fadeOutDown': isSubmittingNewItem, 'fadeIn': !isSubmittingNewItem}"
                   style="width: 95%;"/>
        </Col>
        <Col span="6">
          <i-switch :value="prependNewItem"
                    @on-change="prependNewItemChange();
                                focusOnInput();"
                    size="large"
                   >
            <span slot="open">Head</span>
            <span slot="close">Tail</span>
          </i-switch>
        </Col>
      </Row>
    </form>
    <div class="showDoneLink">
      <Button v-if="!showDone"
              type="dashed"
              shape="circle"
              :disabled="isBoardItemsEmpty"
              @click="switchShowDone">Show done
      </Button>
      <Button v-if="showDone"
              type="dashed"
              shape="circle"
              :disabled="isBoardItemsEmpty"
              @click="switchShowDone">
        Hide done
      </Button>
    </div>
    <div v-if="isBoardItemsEmpty" class="info">
      <h1>No items on this board, yet</h1>
    </div>

    <div v-if="isAllItemsDone" class="info">
      <h1>Great, all items are done!</h1>
    </div>
    <draggable :list="boardItems" @change="boardItemsRearanged" :options="{ghostClass: 'sortable-ghost'}">
      <transition-group name="list-complete">
        <board-item v-for="item in boardItems"
                    :key="item.id"
                    :itemId="item.id"
                    :isDone="item.isDone"
                    :text="item.text"
                    :created="item.created"
                    :showDate="showDate"
                    :setAlarm="setAlarm"
                    v-if="shouldBeDisplayed(item)"
                    @changeIsDone="changeIsDone"
                    @removeItem="removeItem"
                    @changeItemVal="changeItemVal"
        >
        </board-item>
      </transition-group>
    </draggable>
  </div>
</template>

<script>
  import draggable from 'vuedraggable'
  import XXH from 'xxhashjs'
  import BoardItem from './BoardItem.vue'
  const Rx = require('rxjs/Rx')
  const moment = require('moment')
  const storage = require('electron').remote.require('electron-settings')
  const notifier = require('electron').remote.require('electron-notifications')

  export default {
    name: 'board',
    props: ['boardId', 'selectedTab', 'showDone', 'prependNewItem', 'showDate', 'setAlarm'],
    components: {
      BoardItem,
      draggable
    },
    data () {
      return {
        boardItems: [],
        newTodoItem: '',
        isSubmittingNewItem: false,
        isEditingItem: false
      }
    },
    computed: {
      isActive () {
        return this.boardId === this.selectedTab
      },
      isBoardItemsEmpty () {
        return !this.boardItems.length
      },
      isAllItemsDone () {
        return this.boardItems.length && !this.boardItems.find(item => !item.isDone)
      }
    },
    methods: {
      boardItemsRearanged () {
        this.saveBoardItems()
      },
      prependNewItemChange () {
        this.$emit('prependNewItemChange', !this.prependNewItem, this.boardId)
      },
      switchShowDone () {
        this.$emit('showDoneSwitched', !this.showDone, this.boardId)
      },
      changeIsDone (itemId, newVal) {
        console.log('changeIsDone', itemId, newVal)
        console.log('changeIsDone setAlarm', this.setAlarm)
        this.boardItems.find(item => item.id === itemId).isDone = newVal
        this.boardItems = this.boardItems.slice(0)
        this.saveBoardItems()
      },
      shouldBeDisplayed (item) {
        if (!item.isDone) {
          return true
        }
        return this.showDone
      },
      submitNewItem () {
        if (this.newTodoItem.trim().length === 0) {
          this.newTodoItem = ''
          return
        }
        this.isSubmittingNewItem = true
        const newBoardItem = {
          id: XXH.h32(this.newTodoItem, new Date().getTime()).toString(16),
          text: this.newTodoItem,
          isDone: false,
          created: new Date()
        }
        if (this.prependNewItem) {
          this.boardItems.unshift(newBoardItem)
        } else {
          this.boardItems.push(newBoardItem)
        }
        this.newTodoItem = ''
        this.saveBoardItems()
        this.$Message.success('Item added')
        this.$nextTick(() => {
          this.isSubmittingNewItem = false
        })
      },
      removeItem (itemId) {
        const indexToRemove = this.boardItems.findIndex(el => el.id === itemId)
        if (indexToRemove !== -1) {
          this.boardItems.splice(indexToRemove, 1)
          this.saveBoardItems()
          this.focusOnInput()
          this.$Message.success('Item removed')
        }
      },
      changeItemVal (itemId, itemVal) {
        const item = this.boardItems.find(el => el.id === itemId)
        if (item) {
          item.text = itemVal
          this.boardItems = this.boardItems.slice(0)
          this.saveBoardItems()
        }
        this.focusOnInput()
      },
      focusOnInput () {
        const vm = this
        setTimeout(() => {
          if (vm.$refs['mainInput']) {
            vm.$refs['mainInput'].focus()
          }
        }, 250)
      },
      saveBoardItems () {
        storage.set(`board-item-${this.boardId}`, this.boardItems)
        this.setAlarms()
      },
      fetchBoardItems () {
        console.log('fetchBoardItems', this.boardId, this.setAlarm)
        if (storage.has(`board-item-${this.boardId}`)) {
          this.boardItems = storage.get(`board-item-${this.boardId}`)
          if (this.setAlarm) {
            this.setAlarms()
          }
        }
      },
      setAlarms () {
        const alarms = this.boardItems.filter(b => !b.isDone && b.text.indexOf('at') >= 0)
        console.log(alarms)
        if (alarms) {
          alarms.forEach(a => {
            console.log(a.text)
            Rx.Observable.timer(moment(a.text.substring(a.text.indexOf('at') + 3), 'H:mm').toDate()).subscribe(val => {
              console.log('check time:', a.text)
              if (moment(a.text.substring(a.text.indexOf('at') + 3), 'H:mm').isBefore(Date.now())) {
                console.log('show notification:')
                this.changeIsDone(a.id, true)
                const notification = notifier.notify('Reminder', {
                  message: a.text,
                  icon: 'https://image.flaticon.com/icons/svg/691/691758.svg',
                  buttons: ['Dismiss'],
                  duration: 300000
                })
                notification.on('buttonClicked', () => {
                  notification.close()
                })
              }
            })
          })
        }
      }
    },
    watch: {
      selectedTab () {
        if (this.isActive) {
          this.focusOnInput()
        }
      }
    },
    created () {
      const vm = this
      const boardEnterFn = function (boardId) {
        if (vm.boardId === boardId) {
          vm.focusOnInput()
        }
      }
      this.$bus.$on('boardAdded', boardEnterFn)
      this.$bus.$on('appInit', boardEnterFn)
      this.fetchBoardItems()
    }
  }
</script>

<style>
  .sortable-ghost {
    opacity: 0;
  }

  .info {
    text-align: center;
    font-size: 1.5em;
    opacity: .25;
    padding: 20px 0;
  }

  .showDoneLink {
    text-align: center;
    padding: 20px 0;
  }

  .tab-content {
    padding: 0 20px;
    display: flex;
    flex-direction: column;
    background-color: #ffffff;
  }

  .list-complete-item {
    transition: all .3s;
  }

  .list-complete-enter, .list-complete-leave-to
    /* .list-complete-leave-active below version 2.1.8 */
  {
    opacity: 0;
    transform: translateX(-100%);
  }
</style>
